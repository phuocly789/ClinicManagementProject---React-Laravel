import React, { useState, useEffect, useCallback, useMemo } from "react";
import { Col, Card, Form, Button, Spinner, Badge, Row } from "react-bootstrap";
import Pagination from "../../../Components/Pagination/Pagination";

const API_BASE_URL = 'http://localhost:8000';

const ServicesSection = ({
  services,
  setServices,
  requestedServices,
  setRequestedServices,
  diagnosis,
  isFormDisabled,
  setToast,
  printDocument,
  selectedTodayPatient,
}) => {
  const [localServices, setLocalServices] = useState([]);
  const [localServicesLoading, setLocalServicesLoading] = useState(true);
  const [serviceSuggestions, setServiceSuggestions] = useState([]);
  const [serviceLoading, setServiceLoading] = useState(false);
  const [currentPage, setCurrentPage] = useState(0);
  const itemsPerPage = 8;

  // FIX: T·∫°o local state ƒë·ªÉ qu·∫£n l√Ω ri√™ng
  const [localServicesState, setLocalServicesState] = useState({});

  // ƒê·ªìng b·ªô state t·ª´ props khi component mount
  useEffect(() => {
    if (services && Object.keys(services).length > 0) {
      setLocalServicesState(services);
    }
  }, [services]);

  // Fetch services
  useEffect(() => {
    const fetchServices = async () => {
      try {
        setLocalServicesLoading(true);
        const response = await fetch(`${API_BASE_URL}/api/doctor/services`);
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();
        
        if (Array.isArray(data)) {
          setLocalServices(data);
          // FIX: Kh·ªüi t·∫°o c·∫£ local state v√† prop state
          if (!services || Object.keys(services).length === 0) {
            const initialServices = data.reduce((acc, service) => {
              return { ...acc, [service.ServiceId]: false };
            }, {});
            setLocalServicesState(initialServices);
            setServices(initialServices);
          } else {
            setLocalServicesState(services);
          }
        } else {
          throw new Error("D·ªØ li·ªáu t·ª´ API kh√¥ng ph·∫£i m·∫£ng");
        }
      } catch (error) {
        console.error('Error fetching services:', error);
        setToast({
          show: true,
          message: `L·ªói t·∫£i danh s√°ch d·ªãch v·ª•: ${error.message}`,
          variant: "danger",
        });
        setLocalServices([]);
      } finally {
        setLocalServicesLoading(false);
      }
    };

    fetchServices();
  }, []);

  // Memoize testLabels
  const testLabels = useMemo(() => {
    return localServices.reduce((acc, service) => ({ 
      ...acc, 
      [service.ServiceId]: service.ServiceName 
    }), {});
  }, [localServices]);

  // Pagination
  const { pageCount, currentItems } = useMemo(() => {
    const pageCount = Math.ceil(localServices.length / itemsPerPage);
    const currentItems = localServices.slice(
      currentPage * itemsPerPage, 
      (currentPage + 1) * itemsPerPage
    );
    return { pageCount, currentItems };
  }, [localServices, currentPage, itemsPerPage]);

  // Service suggestions
  useEffect(() => {
    const trimmedDiagnosis = diagnosis?.trim();
    if (!trimmedDiagnosis || trimmedDiagnosis.length < 3) {
      setServiceSuggestions([]);
      return;
    }

    setServiceLoading(true);
    const timeout = setTimeout(async () => {
      try {
        const fetchUrl = `${API_BASE_URL}/api/doctor/ai/suggestion?diagnosis=${encodeURIComponent(trimmedDiagnosis)}&type=service`;
        const res = await fetch(fetchUrl);
        
        if (!res.ok) throw new Error(`HTTP error! Status: ${res.status}`);
        const data = await res.json();

        if (Array.isArray(data)) {
          const normalizedData = data.map(item => ({
            ...item,
            ServiceName: item.ServiceName || item.MedicineName || item.name || 'Unknown Service'
          }));
          setServiceSuggestions(normalizedData);
        } else {
          throw new Error("D·ªØ li·ªáu g·ª£i √Ω d·ªãch v·ª• kh√¥ng ph·∫£i m·∫£ng JSON");
        }
      } catch (err) {
        console.error("Service suggestion error:", err);
        setServiceSuggestions([]);
      } finally {
        setServiceLoading(false);
      }
    }, 800);

    return () => clearTimeout(timeout);
  }, [diagnosis]);

  // Match function
  const findMatchingKey = useCallback((serviceName, labels) => {
    if (!serviceName) return null;
    
    const matchServiceName = (suggestedName, label) => {
      if (!suggestedName || !label) return 0;
      const lowerSuggested = suggestedName.toLowerCase();
      const lowerLabel = label.toLowerCase();

      if (lowerSuggested.includes(lowerLabel) || lowerLabel.includes(lowerSuggested)) {
        return 1.0;
      }

      const wordsSuggested = lowerSuggested.split(/\s+/).filter(w => w.length > 0);
      const wordsLabel = lowerLabel.split(/\s+/).filter(w => w.length > 0);
      if (wordsSuggested.length === 0 || wordsLabel.length === 0) return 0;

      const commonWords = wordsSuggested.filter(word => wordsLabel.includes(word));
      return commonWords.length / Math.max(wordsSuggested.length, wordsLabel.length);
    };

    let bestKey = null;
    let bestScore = 0;

    Object.keys(labels).forEach(key => {
      const score = matchServiceName(serviceName, labels[key]);
      if (score > bestScore) {
        bestScore = score;
        bestKey = key;
      }
    });

    return bestScore > 0.5 ? bestKey : null;
  }, []);

  // FIX: Handle test change - s·ª≠ d·ª•ng local state
  const handleTestChange = useCallback((serviceId) => (e) => {
    const isChecked = e.target.checked;
    console.log('DEBUG - Checkbox changed:', serviceId, isChecked);
    
    // C·∫≠p nh·∫≠t local state ngay l·∫≠p t·ª©c ƒë·ªÉ UI ph·∫£n h·ªìi
    setLocalServicesState(prev => {
      const newState = {
        ...prev,
        [serviceId]: isChecked
      };
      console.log('DEBUG - New LOCAL services state:', newState);
      return newState;
    });

    // ƒê·ªìng b·ªô v·ªõi prop state
    setServices(prev => {
      const newState = {
        ...prev,
        [serviceId]: isChecked
      };
      console.log('DEBUG - New PROP services state:', newState);
      return newState;
    });
  }, [setServices]);

  // Handle request service
  const handleRequestService = useCallback(() => {
    const selected = Object.keys(localServicesState).filter((k) => localServicesState[k]);
    console.log('DEBUG - Selected services from LOCAL state:', selected);
    
    if (selected.length === 0) {
      setToast({
        show: true,
        message: "‚ö†Ô∏è B·∫°n ch∆∞a ch·ªçn d·ªãch v·ª• n√†o.",
        variant: "warning",
      });
      return;
    }

    const updated = { ...requestedServices };
    selected.forEach((id) => (updated[id] = true));
    setRequestedServices(updated);

    setToast({
      show: true,
      message: `‚úÖ ƒê√£ g·ª≠i y√™u c·∫ßu th·ª±c hi·ªán ${selected.length} d·ªãch v·ª• c·∫≠n l√¢m s√†ng.`,
      variant: "success",
    });
  }, [localServicesState, requestedServices, setRequestedServices, setToast]);

  // FIX: Render services - s·ª≠ d·ª•ng localServicesState
  const renderServices = useCallback(() => {
    const half = Math.ceil(currentItems.length / 2);
    const leftColumn = currentItems.slice(0, half);
    const rightColumn = currentItems.slice(half);

    const renderServiceColumn = (columnServices) => 
      columnServices.map((service) => {
        // S·ª≠ d·ª•ng localServicesState thay v√¨ services prop
        const checked = localServicesState[service.ServiceId] || false;
        console.log(`DEBUG - Rendering service ${service.ServiceId}:`, checked);
        
        return (
          <div key={service.ServiceId} className="d-flex justify-content-between align-items-center mb-2">
            <div className="form-check d-flex align-items-center">
              <input
                id={`checkbox-${service.ServiceId}`}
                type="checkbox"
                checked={checked}
                onChange={handleTestChange(service.ServiceId)}
                disabled={isFormDisabled}
                className="form-check-input me-2"
              />
              <label htmlFor={`checkbox-${service.ServiceId}`} className="form-check-label mb-0">
                {service.ServiceName} - {service.Price ? service.Price.toLocaleString() + ' VNƒê' : 'Gi√° ch∆∞a c·∫≠p nh·∫≠t'}
              </label>
            </div>
            {requestedServices[service.ServiceId] && (
              <Badge bg="success" pill className="ms-2">
                ‚úÖ ƒê√£ y√™u c·∫ßu
              </Badge>
            )}
          </div>
        );
      });

    return (
      <Row>
        <Col md={6}>{renderServiceColumn(leftColumn)}</Col>
        <Col md={6}>{renderServiceColumn(rightColumn)}</Col>
      </Row>
    );
  }, [currentItems, localServicesState, requestedServices, isFormDisabled, handleTestChange]);

  const handlePageChange = useCallback(({ selected }) => {
    setCurrentPage(selected);
  }, []);

  // Debug logs
  useEffect(() => {
    console.log('DEBUG - LocalServicesState updated:', localServicesState);
    console.log('DEBUG - Services prop updated:', services);
  }, [localServicesState, services]);

  return (
    <Col md={12}>
      <Card className="mb-3 border-light shadow-sm">
        <Card.Header className="text-start fw-bold">
          2. Ch·ªâ ƒë·ªãnh d·ªãch v·ª• c·∫≠n l√¢m s√†ng
        </Card.Header>
        <Card.Body className="text-start">
          <Form.Group className="mb-3">
            {serviceSuggestions.length > 0 && (
              <div className="ai-suggestions mb-3">
                <h6>ü©∫ G·ª£i √Ω d·ªãch v·ª• ph√π h·ª£p (d·ª±a tr√™n ch·∫©n ƒëo√°n):</h6>
                <ul className="mb-0">
                  {serviceSuggestions.map((service, i) => {
                    const serviceName = service.ServiceName || service.MedicineName || 'Unknown';
                    const serviceKey = findMatchingKey(serviceName, testLabels);

                    return (
                      <li key={`${serviceName}-${i}`}>
                        <div className="medicine-info d-flex justify-content-between align-items-center">
                          <span><b>{serviceName}</b> ‚Äî <i>{service.Reason || "ƒê·ªÅ xu·∫•t d·ª±a tr√™n ch·∫©n ƒëo√°n"}</i></span>
                          <Button
                            variant="outline-primary"
                            size="sm"
                            onClick={() => {
                              if (serviceKey) {
                                const isCurrentlyChecked = localServicesState[serviceKey] || false;
                                const newValue = !isCurrentlyChecked;
                                
                                // C·∫≠p nh·∫≠t c·∫£ local v√† prop state
                                setLocalServicesState(prev => ({
                                  ...prev,
                                  [serviceKey]: newValue
                                }));
                                setServices(prev => ({
                                  ...prev,
                                  [serviceKey]: newValue
                                }));
                                
                                setToast({
                                  show: true,
                                  message: `‚úÖ ƒê√£ ${newValue ? 'ch·ªçn' : 'b·ªè ch·ªçn'} d·ªãch v·ª• "${serviceName}".`,
                                  variant: "success",
                                });
                              } else {
                                setToast({
                                  show: true,
                                  message: `‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y d·ªãch v·ª• t∆∞∆°ng ·ª©ng cho "${serviceName}".`,
                                  variant: "warning",
                                });
                              }
                            }}
                          >
                            {serviceKey ? (localServicesState[serviceKey] ? "‚úì ƒê√£ ch·ªçn" : "+ Ch·ªçn") : "Kh√¥ng kh·∫£ d·ª•ng"}
                          </Button>
                        </div>
                      </li>
                    );
                  })}
                </ul>
              </div>
            )}
            
            {serviceLoading && (
              <div className="text-center mt-2">
                <Spinner animation="border" size="sm" /> ƒêang t·∫£i g·ª£i √Ω d·ªãch v·ª•...
              </div>
            )}

            <h6>Danh s√°ch d·ªãch v·ª• kh·∫£ d·ª•ng:</h6>
            {localServicesLoading ? (
              <div className="text-center">
                <Spinner animation="border" size="sm" /> ƒêang t·∫£i danh s√°ch d·ªãch v·ª•...
              </div>
            ) : localServices.length === 0 ? (
              <p className="text-muted">Kh√¥ng c√≥ d·ªãch v·ª• n√†o kh·∫£ d·ª•ng.</p>
            ) : (
              <>
                {renderServices()}
                <Pagination
                  pageCount={pageCount}
                  onPageChange={handlePageChange}
                  currentPage={currentPage}
                  isFormDisabled={localServicesLoading}
                />
              </>
            )}
          </Form.Group>

          <div className="text-end">
            <Button
              variant="outline-primary"
              size="sm"
              onClick={handleRequestService}
              disabled={isFormDisabled || !Object.values(localServicesState).some(v => v)}
              className="no-print"
            >
              üßæ Y√™u c·∫ßu th·ª±c hi·ªán d·ªãch v·ª• ƒë√£ ch·ªçn ({Object.values(localServicesState).filter(v => v).length})
            </Button>
            <Button
              variant="outline-success"
              size="sm"
              onClick={() => printDocument('service')}
              disabled={!selectedTodayPatient || !Object.values(localServicesState).some(Boolean)}
              className="no-print ms-2"
            >
              üñ®Ô∏è Xu·∫•t ch·ªâ ƒë·ªãnh d·ªãch v·ª•
            </Button>
          </div>

          <hr />
          <p>
            <strong>K·∫øt qu·∫£ (n·∫øu c√≥):</strong>{" "}
            <a href="#">Xem file ƒë√≠nh k√®m...</a>
          </p>
        </Card.Body>
      </Card>
    </Col>
  );
};

export default React.memo(ServicesSection);